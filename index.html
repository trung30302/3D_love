<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üíñY√äU EM B√âüíñ</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%;
    background: linear-gradient(135deg, #c53263, #fa75a4);
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 9999;
  }
</style>
</head>
<body>
     
<!-- Th√™m hi·ªáu ·ª©ng 3D s·ª≠ d·ª•ng Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function(){
     // T·∫°o scene, camera, renderer cho hi·ªáu ·ª©ng 3D
     const scene = new THREE.Scene();
     const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
     const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
     renderer.setSize(window.innerWidth, window.innerHeight);
     renderer.domElement.style.position = 'fixed';
     renderer.domElement.style.top = 0;
     renderer.domElement.style.left = 0;
     renderer.domElement.style.zIndex = 9998;
     document.body.appendChild(renderer.domElement);

     window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
     });

     // H√†m t·∫°o h√¨nh tr√°i tim theo d·∫°ng shape
     function createHeartShape(){
          const shape = new THREE.Shape();
          shape.moveTo( 0, 0 );
          shape.bezierCurveTo( 0, 0, -2, -2, -4, -2 );
          shape.bezierCurveTo( -7, -2, -7, 1.5, -7, 1.5 );
          shape.bezierCurveTo( -7, 4, -4, 6, 0, 8 );
          shape.bezierCurveTo( 4, 6, 7, 4, 7, 1.5 );
          shape.bezierCurveTo( 7, 1.5, 7, -2, 4, -2 );
          shape.bezierCurveTo( 2, -2, 0, 0, 0, 0 );
          return shape;
     }

     // T·∫°o geometry v√† material cho tr√°i tim 3D
     const heartShape = createHeartShape();
     const extrudeSettings = { depth: 2, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.5 };
     const heartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
     const heartMaterial = new THREE.MeshPhongMaterial({ color: 0xff69b4 });

     // Nh√≥m c√°c tr√°i tim ƒë·ªÉ d·ªÖ qu·∫£n l√Ω animation
     const heartsGroup = new THREE.Group();
     const heartsCount = 30;
     for(let i=0; i<heartsCount; i++){
          const heartMesh = new THREE.Mesh(heartGeometry, heartMaterial);
          heartMesh.position.x = Math.random() * window.innerWidth - window.innerWidth/2;
          heartMesh.position.y = Math.random() * window.innerHeight - window.innerHeight/2;
          heartMesh.position.z = Math.random() * -500;
          heartMesh.rotation.z = Math.random() * Math.PI;
          heartsGroup.add(heartMesh);
     }
     scene.add(heartsGroup);

     // Th√™m √°nh s√°ng cho scene
     const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
     directionalLight.position.set(0, 0, 500);
     scene.add(directionalLight);

     camera.position.z = 500;

     // V√≤ng l·∫∑p animation cho hi·ªáu ·ª©ng 3D
     function animate3D(){
          requestAnimationFrame(animate3D);
          heartsGroup.children.forEach(heart => {
               heart.rotation.x += 0.01;
               heart.rotation.y += 0.01;
               heart.position.y -= 1;
               if(heart.position.y < -window.innerHeight/2 - 50){
                    heart.position.y = window.innerHeight/2 + 50;
               }
          });
          renderer.render(scene, camera);
     }
     animate3D();
})();
</script>
<script>
(function(){
     const textCanvas = document.createElement('canvas');
     textCanvas.style.position = 'fixed';
     textCanvas.style.top = 0;
     textCanvas.style.left = 0;
     textCanvas.style.width = '100vw';
     textCanvas.style.height = '100vh';
     textCanvas.style.pointerEvents = 'none';
     textCanvas.style.zIndex = 10000;
     document.body.appendChild(textCanvas);
     const ctx = textCanvas.getContext('2d');

     let cw = window.innerWidth, ch = window.innerHeight;
     textCanvas.width = cw;
     textCanvas.height = ch;

     window.addEventListener('resize', () => {
          cw = window.innerWidth;
          ch = window.innerHeight;
          textCanvas.width = cw;
          textCanvas.height = ch;
     });
     ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
     ctx.shadowBlur = 20; 
     const fallingTexts = [];
     const sampleTexts = ["Ch√∫c em b√© 01/06 th·∫≠t vui v·∫ª v√† √Ω nghƒ©a", "LOVE", "üíñ", "Anh y√™u em b√© nhi·ªÅu!!üíñ",];
     const textsCount = 10; // S·ªë l∆∞·ª£ng vƒÉn b·∫£n r∆°i xu·ªëng
     for (let i = 0; i < textsCount; i++) {
          fallingTexts.push({
               text: sampleTexts[Math.floor(Math.random() * sampleTexts.length)],
               x: Math.random() * cw,
               y: Math.random() * ch,
               speed: Math.random() * 1 + 0.5,
               fontSize: Math.random() * 20 + 30,
               opacity: Math.random() * 0.5 + 0.5
          });
     }

     function animateFallingText(){
          ctx.clearRect(0, 0, cw, ch);
          fallingTexts.forEach(item => {
               ctx.font = item.fontSize + "px Arial";
               ctx.fillStyle = "rgba(255,255,255," + item.opacity + ")";
               ctx.fillText(item.text, item.x, item.y);
               item.y += item.speed;
               if(item.y > ch){
                    item.y = -item.fontSize;
                    item.x = Math.random() * cw;
               }
          });
          requestAnimationFrame(animateFallingText);
     }
     animateFallingText();
})();
</script>

<script>
(function(){
     const imagesCanvas = document.createElement('canvas');
     imagesCanvas.style.position = 'fixed';
     imagesCanvas.style.top = 0;
     imagesCanvas.style.left = 0;
     imagesCanvas.style.width = '100vw';
     imagesCanvas.style.height = '100vh';
     imagesCanvas.style.pointerEvents = 'none';
     imagesCanvas.style.zIndex = 10001;
     document.body.appendChild(imagesCanvas);

     const ctx = imagesCanvas.getContext('2d');
     let cw = window.innerWidth, ch = window.innerHeight;
     imagesCanvas.width = cw;
     imagesCanvas.height = ch;

     window.addEventListener('resize', () => {
           cw = window.innerWidth;
           ch = window.innerHeight;
           imagesCanvas.width = cw;
           imagesCanvas.height = ch;
     });

     const fallingImages = [];
     const imagesCount = 5;
     const imageUrls = [
          'images/1.jpg',
          'images/2.jpg',
          'images/3.jpg',
          'images/4.jpg',
          'images/5.jpg',
     ];

     function random(min, max) {
           return Math.random() * (max - min) + min;
     }
     setTimeout(() => {
          const prevPush = fallingImages.push;
          fallingImages.push = function(...items) {
               // Ch·ªâ th√™m ·∫£nh v·ªõi x√°c su·∫•t 50% v√† ƒëi·ªÅu ch·ªânh v·ªã tr√≠ tr√°nh ch·ªìng l·∫•n
               if (Math.random() < 0.5) {
                    const pad = 20; // kho·∫£ng c√°ch ƒë·ªám ƒë·ªÉ tr√°nh ƒë√® l√™n nhau
                    items = items.map(item => {
                         let attempt = 0;
                         // Ki·ªÉm tra xem ·∫£nh m·ªõi c√≥ ƒë√® l√™n b·∫•t k·ª≥ ·∫£nh n√†o ƒë√£ c√≥ kh√¥ng,
                         // n·∫øu c√≥, th·ª≠ t·∫°o v·ªã tr√≠ m·ªõi (t·ªëi ƒëa 10 l·∫ßn)
                         while (
                              attempt < 10 &&
                              fallingImages.some(existing =>
                                   !(
                                        item.x + item.width + pad < existing.x ||
                                        item.x > existing.x + existing.width + pad ||
                                        item.y + item.height + pad < existing.y ||
                                        item.y > existing.y + existing.height + pad
                                   )
                              )
                         ) {
                              item.x = random(0, cw);
                              item.y = random(0, ch);
                              attempt++;
                         }
                         return item;
                    });
                    return prevPush.apply(this, items);
               }
               return this.length;
          };
     }, 0);
     // Gi·∫£m t·∫ßn su·∫•t th√™m ·∫£nh b·∫±ng c√°ch ghi ƒë√® ph∆∞∆°ng th·ª©c push c·ªßa m·∫£ng fallingImages
    
     // Preload images and create falling image objects for each loaded image
     imageUrls.forEach(url => {
           const img = new Image();
           img.src = url;
           img.onload = () => {
                 for (let i = 0; i < imagesCount; i++) {
                       fallingImages.push({
                              img: img,
                              x: random(0, cw),
                              y: random(0, ch), 
                              speed: random(1, 1), // t·ªëc ƒë·ªô r∆°i
                              width: random(100, 150), 
                              height: random(100, 200),
                              swing: random(0.5, 2), // ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng l·∫Øc nh·∫π
                              opacity: random(0.5, 1),
                              swingPhase: random(0, Math.PI * 2)
                       });
                 }
           };
     });

     function animateFallingImages(){
           ctx.clearRect(0, 0, cw, ch);
           fallingImages.forEach(item => {
                 item.swingPhase += 0.02;
                 const offsetX = Math.sin(item.swingPhase) * item.swing;
                 ctx.drawImage(item.img, item.x + offsetX, item.y, item.width, item.height);
                 item.y += item.speed;
                 if(item.y > ch){
                       item.y = -item.height;
                       item.x = random(0, cw);
                 }
           });
           requestAnimationFrame(animateFallingImages);
     }
     animateFallingImages();
})();
</script>
</script>
<canvas id="hearts"></canvas>

<script>
(() => {
  const canvas = document.getElementById('hearts');
  const ctx = canvas.getContext('2d');

  let width, height;
  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  }
  resize();
  window.addEventListener('resize', resize);

  // T·∫°o m·∫£ng tr√°i tim
  const heartsCount = 60;
  const hearts = [];

  function random(min, max) {
    return Math.random() * (max - min) + min;
  }

  for (let i = 0; i < heartsCount; i++) {
    hearts.push({
      x: random(0, width),
      y: random(0, height),
      size: random(10, 25),
      speed: random(1, 3), //
      opacity: random(0.3, 0.9),
      swing: random(0.5, 2),  // ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng l·∫Øc nh·∫π tr√°i tim theo chi·ªÅu ngang
      swingPhase: random(0, Math.PI * 2)
    });
  }

  function drawHeart(x, y, size, opacity) {
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.fillStyle = 'pink';
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x, y - size / 2, x - size, y - size / 2, x - size, y);
    ctx.bezierCurveTo(x - size, y + size / 2, x, y + size * 0.75, x, y + size);
    ctx.bezierCurveTo(x, y + size * 0.75, x + size, y + size / 2, x + size, y);
    ctx.bezierCurveTo(x + size, y - size / 2, x, y - size / 2, x, y);
    ctx.fill();
    ctx.restore();
  }

  function animate() {
    ctx.clearRect(0, 0, width, height);
    hearts.forEach(h => {
      // T·∫°o hi·ªáu ·ª©ng l·∫Øc nh·∫π tr√°i tim theo chi·ªÅu ngang
      h.swingPhase += 0.02;
      const offsetX = Math.sin(h.swingPhase) * h.swing;

      drawHeart(h.x + offsetX, h.y, h.size, h.opacity);
      h.y += h.speed;

      // Reset khi r∆°i xu·ªëng ƒë√°y
      if (h.y - h.size > height) {
        h.y = -h.size;
        h.x = random(0, width);
        h.opacity = random(0.3, 0.9);
        h.size = random(10, 25);
        h.speed = random(1, 3); //
        h.swing = random(0.5, 2);
        h.swingPhase = random(0, Math.PI * 2);
      }
    });
    requestAnimationFrame(animate);
  }

  animate();
})();
</script>

</body>
</html>
